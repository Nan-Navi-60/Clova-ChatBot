// e2eTests/chatbot.spec.js
import { test, expect } from '@playwright/test';

test.beforeEach(async ({ page }) => {
  await page.goto('/');
});

// Case 1. [엔터 키] 전송 테스트
test('Case 1: Send message using Enter key', async ({ page }) => {
  const message = '안녕하세요';
  
  // 1. 입력창 찾기 및 입력
  await page.fill('textarea#userInput', message);
  
  // 2. 엔터 키 입력
  await page.press('textarea#userInput', 'Enter');

  // 3. 내 메시지가 화면에 떴는지 확인 (ChatItems.jsx의 클래스 구조 반영)
  // 'a.message.user'가 실제 메시지 텍스트를 담고 있음
  await expect(page.locator('a.message.user').last()).toHaveText(message);
  
  // 4. 입력창이 비워졌는지 확인
  await expect(page.locator('textarea#userInput')).toHaveValue('');
});

// Case 2. [전송 버튼] 전송 테스트
test('Case 2: Send message using send button', async ({ page }) => {
  const message = '반갑습니다';
  
  await page.fill('textarea#userInput', message);
  
  // [중요] 현재 ChatInput.jsx에 onClick이 없어서 이 테스트는 무조건 실패해야 정상입니다.
  // 소스 코드를 수정한 후에는 통과할 것입니다.
  await page.click('button#sendBtn');

  await expect(page.locator('a.message.user').last()).toHaveText(message);
  await expect(page.locator('textarea#userInput')).toHaveValue('');
});

// Case 3. [초기화 버튼] 테스트
test('Case 3: Clear all chat messages', async ({ page }) => {
  await page.fill('textarea#userInput', 'Test message');
  await page.press('textarea#userInput', 'Enter');
  
  // 메시지 전송 후 챗봇 응답(로딩) 기다림
  await expect(page.locator('a.message.user').last()).toBeVisible();

  // [수정 포인트] ChatBody.jsx 로직상 버튼이 보일 때까지 기다려야 함
  // 만약 버튼이 끝까지 안 나타나면 소스 코드 로직 문제임
  const resetBtn = page.locator('button', { hasText: '대화 기록 초기화' });
  
  // 버튼이 렌더링될 때까지 최대 5초 대기 (조건부 렌더링 때문)
  if (await resetBtn.isVisible()) {
      await resetBtn.click();
      // 초기화 후 유저 메시지가 0개가 되었는지 확인
      await expect(page.locator('a.message.user')).toHaveCount(0);
  } else {
      console.log('Case 3 Skip: 초기화 버튼이 화면에 나타나지 않았습니다 (소스코드 조건 확인 필요)');
  }
});

// Case 5. [로딩 표시] 테스트
test('Case 5: Loading indicator displayed', async ({ page }) => {
  await page.fill('textarea#userInput', 'Loading test');
  await page.press('textarea#userInput', 'Enter');

  // ChatBody.jsx에서 Loading 컴포넌트는 'a.message.bot' 안에 렌더링됨
  // 텍스트가 아니라 스피너 이미지나 SVG일 수 있으므로 .toBeVisible()로 체크
  const botMessage = page.locator('a.message.bot').last();
  await expect(botMessage).toBeVisible();
});

// Case 6. [시간 표시] 테스트
test('Case 6: Timestamp displayed', async ({ page }) => {
  await page.fill('textarea#userInput', 'Time check');
  await page.press('textarea#userInput', 'Enter');

  // ChatItems.jsx 구조: div > a.message + a.text-xs
  // 마지막 메시지(방금 보낸 거)의 시간 요소 찾기
  // tailwind 클래스 .text-gray-400 등을 이용
  const timeLabel = page.locator('a.text-xs.text-gray-400').last();
  
  await expect(timeLabel).toBeVisible();
  const timeText = await timeLabel.textContent();
  
  // 정규식으로 HH:mm 포맷 확인 (예: 14:30)
  expect(timeText).toMatch(/^\d{2}:\s\d{2}$/); // ChatItems.jsx에 ": " 공백이 있을 수 있음
});

// Case 7. [스크롤] 테스트
test('Case 7: Auto-scroll to bottom', async ({ page }) => {
  // 메시지를 여러 개 보내서 스크롤을 발생시킴
  for (let i = 0; i < 10; i++) {
    await page.fill('textarea#userInput', `Message ${i}`);
    await page.press('textarea#userInput', 'Enter');
    // 너무 빨리 보내면 씹힐 수 있으니 약간 대기
    await page.waitForTimeout(100); 
  }

  const chatBody = page.locator('#chat-body');
  
  // 스크롤이 바닥에 있는지 확인하는 로직
  const isAtBottom = await chatBody.evaluate((el) => {
    return el.scrollHeight - el.scrollTop <= el.clientHeight + 50; // 오차 범위 50px
  });

  expect(isAtBottom).toBeTruthy();
});

// Case 9. [History] 열기 테스트
test('Case 9: History open and check', async ({ page }) => {
  // 1. 메시지 하나 전송해서 히스토리 생성 (백엔드 로직에 따라 다를 수 있음)
  await page.fill('textarea#userInput', 'History Item');
  await page.press('textarea#userInput', 'Enter');

  // 2. ChatHeader.jsx의 스크롤 아이콘(History 버튼) 클릭
  await page.click('img[alt="scroll"]');

  // 3. History 컴포넌트들이 렌더링되었는지 확인
  // History.jsx의 최상위 div 클래스 일부를 이용해 찾기
  const historyItem = page.locator('div.bg-sky-200').first();
  
  // 히스토리가 뜬다면 아이템이 보여야 함
  // (만약 히스토리가 비동기로 불러와진다면 시간이 걸릴 수 있음)
  await expect(historyItem).toBeVisible({ timeout: 5000 });
});