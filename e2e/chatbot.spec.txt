// e2eTests/chatbot.spec.js
import { test, expect } from '@playwright/test';

test.beforeEach(async ({ page }) => {
  await page.goto('/'); // Base URL configured in playwright.config.js
});

// Case 1. [엔터 키]를 이용한 메시지 전송
test('Case 1: Send message using Enter key', async ({ page }) => {
  const message = '안녕하세요';
  await page.fill('textarea#userInput', message);
  await page.press('textarea#userInput', 'Enter');

  // Check if message is added to chat list
  await expect(page.locator('a.message.user').last()).toHaveText(message);
  // Check if input field is empty
  await expect(page.locator('textarea#userInput')).toHaveValue('');
});

// Case 2. [전송 버튼]을 이용한 메시지 전송
test('Case 2: Send message using send button', async ({ page }) => {
  const message = '반갑습니다';
  await page.fill('textarea#userInput', message);
  await page.click('button#sendBtn');

  // Check if message is added to chat list
  await expect(page.locator('a.message.user').last()).toHaveText(message);
  // Check if input field is empty
  await expect(page.locator('textarea#userInput')).toHaveValue('');
});

// Case 3. [전체 초기화 버튼]
test('Case 3: Clear all chat messages', async ({ page }) => {
  // Send a message to ensure there's content to clear
  await page.fill('textarea#userInput', 'Test message for clear');
  await page.press('textarea#userInput', 'Enter');
  // Wait for the message to appear and possibly for the bot's response
  await expect(page.locator('.chat-bubble-user').last()).toBeVisible();

  // Click the '전체 초기화' button (assuming it's visible in the UI)
  // I need to find the correct selector for this button. Assuming it's a button with specific text.
  await page.click('button:has-text("대화 기록 초기화")'); 

  // Expect only the welcome message to be present. This requires knowing the welcome message's text or selector.
  // For now, let's assert that user messages are gone and a welcome message is visible.
  await expect(page.locator('a.message.user')).toHaveCount(0);
  // Assuming a welcome message from the bot will be the only one present.
  // This selector might need adjustment based on the actual welcome message's HTML.
  await expect(page.locator('a.message.bot')).toHaveCount(1);
});

// Case 4. [응답 전까지 재요청 불가능] - This case needs a mock or way to delay bot response.
// For now, I'll simulate by sending a message and immediately trying to send another.
// This test might be flaky if the bot responds too quickly. A more robust test would involve mocking the API.
test('Case 4: Cannot re-request until response is received', async ({ page }) => {
  const message1 = 'First message';
  await page.fill('textarea#userInput', message1);
  await page.press('textarea#userInput', 'Enter');

  // Expect send button to be disabled
  const sendButton = page.locator('button#sendBtn');
  await expect(sendButton).toBeDisabled();

  // Try to type another message and press Enter, it should not be sent
  await page.fill('textarea#userInput', 'Second message');
  await page.press('textarea#userInput', 'Enter', { delay: 100 }); // Short delay

  // The first message should appear, but the second should not if the button is disabled
  await expect(page.locator('a.message.user').last()).toHaveText(message1);
  // Wait for the bot's response to enable the button again
  await expect(sendButton).toBeEnabled();
  // Ensure the second message was not added to the chat
  const chatBubbles = await page.locator('a.message.user').allTextContents();
  expect(chatBubbles).not.toContain('Second message');
});

// Case 5. [로딩 중 표시] - This also needs a delayed bot response or mock.
test('Case 5: Loading indicator displayed during bot response', async ({ page }) => {
  await page.fill('textarea#userInput', 'Loading test');
  await page.press('textarea#userInput', 'Enter');

  // Expect loading indicator to appear
  await expect(page.locator('a.message.bot')).toBeVisible();

  // Wait for the bot's response to replace the loading indicator
  await expect(page.locator('a.message.bot').last()).toBeVisible();
  await expect(page.locator('a.message.bot')).not.toBeVisible();
});

// Case 6. [시간 표시] - This depends on the format and presence of time in the UI.
test('Case 6: Timestamp displayed for each message', async ({ page }) => {
  await page.fill('textarea#userInput', 'Time test');
  await page.press('textarea#userInput', 'Enter');

  // Wait for both user and bot messages
  await expect(page.locator('a.message.user').last()).toBeVisible();
  await expect(page.locator('a.message.bot').last()).toBeVisible();

  // Check user message for time format HH:mm
  const userMessageTime = await page.locator('div.flex.flex-col.items-end > a.text-xs.text-gray-400').last().textContent();
  expect(userMessageTime).toMatch(/^\d{2}:\d{2}$/); // e.g., "21:58"

  // Check bot message for time format HH:mm
  const botMessageTime = await page.locator('div.flex.flex-col.items-start > a.text-xs.text-gray-400').last().textContent();
  expect(botMessageTime).toMatch(/^\d{2}:\d{2}$/);
});

// Case 7. [스크롤 자동화]
test('Case 7: Chat auto-scrolls to bottom on new message', async ({ page }) => {
  // Send multiple messages to fill up the chat window and enable scrolling
  for (let i = 0; i < 15; i++) { // Assuming 15 messages will cause overflow
    await page.fill('textarea#userInput', `Scroll test message ${i}`);
    await page.press('textarea#userInput', 'Enter');
    await expect(page.locator('a.message.user').last()).toBeVisible();
    // Wait for bot response to ensure the chat window is updated before next message
    // This part might need adjustment based on actual bot response speed and UI
    await expect(page.locator('a.message.bot').last()).toBeVisible();
  }

  // After sending many messages, check if the scroll is at the bottom
  const chatBody = page.locator('#chat-body'); // Selector for the scrollable chat area
  await expect(chatBody).toHaveProperty('scrollHeight');
  await expect(chatBody).toHaveProperty('scrollTop');

  // Evaluate in browser context to check if scroll is at the bottom
  const isScrolledToBottom = await chatBody.evaluate((element) => {
    return element.scrollHeight - element.scrollTop <= element.clientHeight + 5; // +5 for tolerance
  });
  expect(isScrolledToBottom).toBeTruthy();
});

// Case 8. [쉬프트 줄바꿈]
test('Case 8: Shift+Enter creates a new line, not send message', async ({ page }) => {
  const inputField = page.locator('textarea#userInput');
  await inputField.type('First line');
  await inputField.press('Shift+Enter');
  await inputField.type('Second line');

  await expect(inputField).toHaveValue('First line\nSecond line');

  // Ensure no message was sent
  await expect(page.locator('a.message.user')).toHaveCount(0); // If no prior messages
  // Or check the last message before this test if there were any
});

// Case 9. [History - 내역 조회 및 입력]
test('Case 9: History lookup and input', async ({ page }) => {
  // First, send a message to create history
  await page.fill('textarea#userInput', 'History item 1');
  await page.press('textarea#userInput', 'Enter');
  await expect(page.locator('a.message.user').last()).toBeVisible();
  await expect(page.locator('button#sendBtn')).toBeEnabled(); // Wait for bot response

  // Click 'History' button (assuming selector)
  await page.click('img[alt="scroll"]'); // Adjust selector as needed

  // Expect history sidebar/popup to be visible
  const historySidebar = page.locator('div.absolute.overflow-y-auto'); // Adjust selector
  await expect(historySidebar).toBeVisible();

  // Click on a history item (assuming it contains the text 'History item 1')
  await historySidebar.locator('div.flex.flex-col.items-start.bg-sky-200 >> text="History item 1"').click(); // Adjust selector for history items

  // Expect input field to be populated with the clicked history item's text
  const inputField = page.locator('textarea#userInput');
  await expect(inputField).toHaveValue('History item 1');
});

// Case 10. [History - 기록 모두 삭제]
test('Case 10: Clear all history records', async ({ page }) => {
  // Ensure some history exists
  await page.fill('textarea#userInput', 'History to delete');
  await page.press('textarea#userInput', 'Enter');
  await expect(page.locator('a.message.user').last()).toBeVisible();
  await expect(page.locator('button#sendBtn')).toBeEnabled(); // Wait for bot response

  // Open history
  await page.click('img[alt="scroll"]');
  const historySidebar = page.locator('div.absolute.overflow-y-auto');
  await expect(historySidebar).toBeVisible();

  // Click '기록 모두 삭제' button
  await historySidebar.click('button:has-text("기록 모두 삭제")'); // Adjust selector

  // Expect history items to be gone and a message like "기록이 없습니다"
  await expect(historySidebar.locator('div.flex.flex-col.items-start.bg-sky-200')).toHaveCount(0); // Assuming history items have this class
  await expect(historySidebar.locator('text="기록이 없습니다"')).toBeVisible(); // Adjust selector for empty message
});
